---
published: false
layout: post
title: WTF is FP? A Definition for the Mildly Interested
summary: >-
  Journey to Functional Wonderland: Part 3
image: /assets/2021/fp.png
---

![splash](/assets/2021/fp.png)

Ever caught yourself spending an unreasonable amount of time trying to name somethingÂ¹, or pondering over architectural concernsÂ² that **you couldn't care less about**, out of fear that some choices may come back to haunt you?

As stated in the [intro to this series](https://impure.fun/fun/2021/02/16/journey-to-functional-wonderland/), most devs just care about **writing simple code that works**, but it's surprisingly easy to accidentally stray from that goal.

You've been creating and using functions your whole developer life, but if functions aren't exclusive to Functional Programming, what makes it "functional" and â€” more importantly â€” how can things you're already using possibly solve the problems you may still be facing?

Bonus question: when you look at the picture below, do you see a fridge?

<blockquote class="twitter-tweet" data-theme="dark"><p lang="en" dir="ltr">What do you see in the picture? A piece of cardboard? Some junk? No! â€” Itâ€™s a model!<br><br>Thread on models and bounded contexts 1/9<a href="https://twitter.com/hashtag/DDDesign?src=hash&amp;ref_src=twsrc%5Etfw">#DDDesign</a> <a href="https://twitter.com/hashtag/BoundedContext?src=hash&amp;ref_src=twsrc%5Etfw">#BoundedContext</a> <a href="https://t.co/URvUGh6Ho7">pic.twitter.com/URvUGh6Ho7</a></p>&mdash; Vladik Khononov (@vladikk) <a href="https://twitter.com/vladikk/status/1335947978482339841?ref_src=twsrc%5Etfw">December 7, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

## Bear with me

Programming is mostly **modeling real world problems**. As pointed out by Vladik, the statistician [George Box](https://en.wikipedia.org/wiki/George_E._P._Box) once said:

> All models are wrong but some are useful

If programming is modelling, and all models are wrong, one could define programming as devising **the simplest most useful model to solve a problem**. Simplicity and usefulness are the goals, not accuracy.

The real world is seemingly made of objects, so one can easily understand the appeal of Object Oriented Programming. 

But model design has largely transitioned **away from describing stuff** to composing with smaller abstractions that only make sense in very limited contexts, have little-to-no resemblance to the things they represent, but still **get the job done**.

If we're no longer describing stuff, it may be time to revisit the appeal of a programming paradigm that's clearly meant to describe it.

## A surprisingly simple distinction

It's fair to say that **OOP** focuses on what **is** while **FP** focuses on what **happens**. This distinction dramatically influences the problems <sup>[1]</sup> and <sup>[2]</sup> from above, and I'll start with what may cause OOP devs to spend too much time on the 2<sup>nd</sup> one:

What something *is* **depends on the context**. Take MVC for instance, which you may know by MVVM or MVP, it's all about representing something with different objects specialized for the context in which they're being used.

But what something *is* also **changes over time**, which is why in a lasting evolving business you shouldn't be too eager to spend time and energy describing stuff that's going to change anyway.

Interestingly, while what something *is* varies, what *happens* doesn't. The "+" in `2 + 2` is something that performs an arithmetic operation that you're all familiar with, and the context is irrelevant.

Had you written your functional application for King Arthur in CeltScript, you'd probably have used it to add cows, today you'd use the same code to add bitcoins, no refactoring necessary because you focused on what **happens** instead of:

### Â¹ Naming, classifying, and categorizing all the things

It's true that many great apps were done in OOP, but that's missing the greater point: It's not that the wrong tool for the job doesn't get the job done, it's all of the unnecessary frustration it may cause along the way.

And this problem doesn't scale well, the more linearly complex the job is, the exponentially greater the frustration becomes.

## We're ready for a definition!

Now that we've established that programming is basically modelling, we can safely guess what Functional Programming is: Modelling real world problems and solutions with functions.

You still use all the familiar things like strings, ints, floats, array and yes, some like myself even use objects, but the occurrence of these is only dictated by the function signatures. They're either the input or the output of a function, or some intermediate artifact immaterial to the outer scope, but they're never part of some grand hierarchical architecture that some poor soul had to contrive into existence.

Remember, a model isn't trying to accurately recreate the real world, it's trying to efficiently solve for a problem. Solving for a problem isn't "stuff", it's "doing stuff", it's providing the appropriate output for a given input. It's a function. It always has been.

## The real world case for FP

I understand that even with all this talk about models, it's possible some of you still find comfort in their programming paradigm being object oriented because the real world is seemingly made of objects.

I'd like to leave you with some 18th-century wisdom from our friend [Antoine Lavoisier](https://en.wikipedia.org/wiki/Antoine_Lavoisier):

> Nothing is lost, nothing is created, everything is transformed

The law of conservation of mass describes **literally everything** as none other than the product of a transformation. 

If everything is the product of a transformation in the real world itself, what if there were a programming paradigm made to describe transformations? ðŸ¤”

That's precisely what FP is!

A transformation, young software alchemist, is just a fanciful medieval name for the all-mighty **function**, the very topic of the next article!

## The journey continues â›µ

This is the first time I write for non-FP programmers, if you exist and are interested in the next article in the series, please let me know by retweeting, liking, or replying to [this twitter thread](https://twitter.com/luwvis/status/1367410901863837700), and until next time, safe journey!